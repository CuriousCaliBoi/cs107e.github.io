{
  "grades": {
    "assign2": {
      "name": "assign2",
      "timeliness": {
        "submit": {
          "when": "Tue 1/30 14:41",
          "status": "on/before duedate",
          "override": ""
        },
        "retests": null,
        "extension": {
          "when": "Wed 1/31 12:07",
          "status": "within grace period",
          "override": ""
        }
      },
      "test_totals": {
        "Clock application": {
          "total": 3,
          "passed": 0
        },
        "Unit tests (P1)": {
          "total": 7,
          "passed": 7
        },
        "Unit tests (P2)": {
          "total": 2,
          "passed": 2
        },
        "Unit tests (P3)": {
          "total": 1,
          "passed": 1
        }
      },
      "test_results": {
        "10-GpioSetFunction": {
          "result": true,
          "explanation": "Student output matches staff ",
          "issue": null,
          "class": "MangoRunDiffOutput",
          "extension_name": null,
          "category": null
        },
        "11-GpioGetFunction": {
          "result": true,
          "explanation": "Student output matches staff ",
          "issue": null,
          "class": "MangoRunDiffOutput",
          "extension_name": null,
          "category": null
        },
        "12-GpioSetFunctionClear": {
          "result": true,
          "explanation": "Student output matches staff ",
          "issue": null,
          "class": "MangoRunDiffOutput",
          "extension_name": null,
          "category": null
        },
        "13-GpioSetFunctionIndependent": {
          "result": true,
          "explanation": "Student output matches staff ",
          "issue": null,
          "class": "MangoRunDiffOutput",
          "extension_name": null,
          "category": null
        },
        "14-GpioRead": {
          "result": true,
          "explanation": "Student output matches staff ",
          "issue": null,
          "class": "MangoRunDiffOutput",
          "extension_name": null,
          "category": null
        },
        "15-GpioWrite": {
          "result": true,
          "explanation": "Student output matches staff ",
          "issue": null,
          "class": "MangoRunDiffOutput",
          "extension_name": null,
          "category": null
        },
        "16-GpioSetGetFunctionAll": {
          "result": true,
          "explanation": "Student output matches staff ",
          "issue": null,
          "class": "MangoRunDiffOutput",
          "extension_name": null,
          "category": null
        },
        "17-GpioReadWriteAll": {
          "result": true,
          "explanation": "Student output matches staff ",
          "issue": null,
          "class": "MangoRunDiffOutput",
          "extension_name": null,
          "category": null
        },
        "18-GpioInvalid": {
          "result": true,
          "explanation": "Student output matches staff ",
          "issue": null,
          "class": "MangoRunDiffOutput",
          "extension_name": null,
          "category": null
        },
        "20-Timer": {
          "result": true,
          "explanation": "Student output matches staff ",
          "issue": null,
          "class": "MangoRunDiffOutput",
          "extension_name": null,
          "category": null
        }
      },
      "review": {
        "timer_asm.s": {
          "lines": "/* File: timer_asm.s\n * ------------------\n * Function to return tick count of mtime machine counter in Mango Pi.\n */\n\n.attribute arch, \"rv64imac_zicsr\"\n\n.globl timer_get_ticks\ntimer_get_ticks:\n    # Take care to use correct dest register (a0) for return value\n    # so as to interoperate with C calling conventions\n    csrr a0,time\n    ret\n",
          "comments": []
        },
        "timer.c": {
          "lines": "/* File: timer.c\n * -------------\n * Provides timer functions to delay for specified time lengths.\n */\n#include \"timer.h\"\n\n// implemented in file timer_asm.s\nextern unsigned long timer_get_ticks(void);\n\nvoid timer_init(void) {\n    // no initialization required for this peripheral\n}\n\nvoid timer_delay(int secs) {\n    timer_delay_us(secs*1000000);\n}\n\nvoid timer_delay_ms(int ms) {\n    timer_delay_us(ms*1000);\n}\n\nvoid timer_delay_us(int us) {\n    unsigned long busy_wait_until = timer_get_ticks() + us * TICKS_PER_USEC;\n    while (timer_get_ticks() < busy_wait_until) {} // spin\n}\n",
          "comments": []
        },
        "cstart.c": {
          "lines": "/* File: cstart.c\n * --------------\n * Provided to you pre-written. In an upcoming lecture, we\n * will discuss what this code does and why it is necessary.\n */\n\n// linker memmap places these symbols at start/end of bss\nextern char __bss_start__, __bss_end__;\n\nextern void main(void);\n\n// The C function _cstart is called from the assembly in start.s\n// _cstart zeroes out the BSS section and then calls main.\n// After return from main(), turns on the onboard act led as\n// a sign of successful completion.\nvoid _cstart(void) {\n    char *bss = &__bss_start__;\n    char *bss_end = &__bss_end__;\n\n    while (bss < bss_end) {\n        *bss++ = 0;\n    }\n\n    // Turn on the blue act led (GPIO PD18) before starting main\n    volatile unsigned int *PD_CFG2 = (unsigned int *)0x02000098;\n    volatile unsigned int *PD_DATA = (unsigned int *)0x020000a0;\n    *PD_CFG2 = (*PD_CFG2 & ~0xf00) | 0x100;\n    *PD_DATA |= (1 << 18);\n\n    main();\n\n    *PD_DATA &= ~(1 << 18); // turn off after main finishes normally\n}\n",
          "comments": []
        },
        "gpio.c": {
          "lines": "/* File: gpio.c\n * ------------\n * Implementations for controlling Mango PI GPIO to set/get functions and read/write data values.\n *\n * Lisa Fung\n */\n\n#include \"gpio.h\"\n#include <stddef.h>\n\nenum { GROUP_B = 0, GROUP_C, GROUP_D, GROUP_E, GROUP_F, GROUP_G };\n\ntypedef struct  {\n    unsigned int group;\n    unsigned int pin_index;\n} gpio_pin_t;\n\n// The gpio_id_t enumeration assigns a symbolic constant for each\n// in such a way to use a single hex constant. The more significant\n// hex digit identifies the group and lower 2 hex digits are pin index:\n//       constant 0xNnn  N = which group,  nn = pin index within group\n//\n// This helper function extracts the group and pin index from a gpio_id_t\n// e.g. GPIO_PB4 belongs to GROUP_B and has pin_index 4\nstatic gpio_pin_t get_group_and_index(gpio_id_t gpio) {\n    gpio_pin_t gp;\n    gp.group = gpio >> 8;\n    gp.pin_index = gpio & 0xff; // lower 2 hex digits\n    return gp;\n}\n\n// The gpio groups are differently sized, e.g. B has 13 pins, C only 8.\n// This helper function confirms that a gpio_id_t is valid (group\n// and pin index are valid)\nbool gpio_id_is_valid(gpio_id_t pin) {\n    gpio_pin_t gp = get_group_and_index(pin);\n    switch (gp.group) {\n        case GROUP_B: return (gp.pin_index <= GPIO_PB_LAST_INDEX);\n        case GROUP_C: return (gp.pin_index <= GPIO_PC_LAST_INDEX);\n        case GROUP_D: return (gp.pin_index <= GPIO_PD_LAST_INDEX);\n        case GROUP_E: return (gp.pin_index <= GPIO_PE_LAST_INDEX);\n        case GROUP_F: return (gp.pin_index <= GPIO_PF_LAST_INDEX);\n        case GROUP_G: return (gp.pin_index <= GPIO_PG_LAST_INDEX);\n        default:      return false;\n    }\n}\n\n// This helper function is suggested to return the address of\n// the config0 register for a gpio group, i.e. get_cfg0_reg(GROUP_B)\n// Refer to the D1 user manual to learn the address the config0 register\n// for each group. Be sure to note how the address of the config1 and\n// config2 register can be computed as relative offset from config0.\n// This function assumes that `group` is valid.\nstatic volatile unsigned int *get_cfg0_reg(unsigned int group) {\n    volatile unsigned int *cfg0_reg = (unsigned int *)0x02000030; //  GROUP_B config register\n    \n    // Add offset, in increments of 0x30 for each port group\n    unsigned int offset = 12; // need 12 4-byte increments to increase by 0x30\n    cfg0_reg += (offset * group); // adds 4-byte increments\n\n    return cfg0_reg;\n\n    // NOTE: Avoid switch-case.\n    // However, if switch-case used, be sure to add `break;` at the end of each case\n    // or else all subsequent cases will be executed.\n}\n\n// This helper function is suggested to return the address of\n// the data register for a gpio group. Refer to the D1 user manual\n// to learn the address of the data register for each group.\n// This function assumes that `group` is valid.\nstatic volatile unsigned int *get_data_reg(unsigned int group) {\n    volatile unsigned int *data_reg = (unsigned int *)0x02000040; // GROUP_B data register\n\n    // Add offset, in increments of 0x30 for each port group\n    unsigned int offset = 12; // need 12 4-byte increments to increase by 0x30\n    data_reg += (offset * group); // adds 4-byte increments\n\n    return data_reg;\n}\n\nvoid gpio_init(void) {\n    // no initialization required for this peripheral\n}\n\nvoid gpio_set_input(gpio_id_t pin) {\n    gpio_set_function(pin, GPIO_FN_INPUT);\n}\n\nvoid gpio_set_output(gpio_id_t pin) {\n    gpio_set_function(pin, GPIO_FN_OUTPUT);\n}\n\n// Sets the function of a GPIO pin given pin and function\n// Does nothing if `pin` or `function` is not valid\nvoid gpio_set_function(gpio_id_t pin, unsigned int function) {\n    // Check pin is valid\n    if (!gpio_id_is_valid(pin)) {\n        return;\n    }\n    \n    // Checks if function is valid (between 0-8, 14-15, inclusive)\n    if (!( (function >= GPIO_FN_INPUT && function <= GPIO_FN_ALT8)\n           || (function >= GPIO_FN_INTERRUPT && function <= GPIO_FN_DISABLED) )) {\n        return;\n    }\n\n    // Get pin group and index\n    gpio_pin_t gp = get_group_and_index(pin);\n    \n    // Get pin_cfg_reg = cfg0_reg + (gp.pin_index / 8)\n    // Config registers are spaced 4 bytes apart starting from cfg0\n    // Pointer adds in 4-byte increments\n    volatile unsigned int *pin_cfg = get_cfg0_reg(gp.group) + (gp.pin_index / 8);   \n\n    // Update function in 4 config bits (0xf = 0b1111)\n    unsigned int shift_amt = (gp.pin_index % 8) * 4;\n    unsigned int mask = 0xf << shift_amt; // 4 config bits for function\n    \n    // set 4 config bits for function to 0b0000, all other pins stay same\n    *pin_cfg &= (~mask);\n    *pin_cfg |= function << shift_amt; // set pin function at 4 config bits\n}\n\n// This function returns pin function. It should NOT edit the config register.\nunsigned int gpio_get_function(gpio_id_t pin) {\n    // Check pin is valid.\n    if (!(gpio_id_is_valid(pin))) {\n        return GPIO_INVALID_REQUEST;\n    }\n    \n    // Get pin group and index\n    gpio_pin_t gp = get_group_and_index(pin);\n    \n    // Pointer to pin's config register\n    volatile unsigned int *pin_cfg = get_cfg0_reg(gp.group) + (gp.pin_index / 8);\n        \n    // Get the 4 config bits with pin function\n    // shift function to be at least significant 4 bits\n    unsigned int shift_amt = (gp.pin_index % 8) * 4;\n    unsigned int mask = 0xf; // mask out last 4 bits to isolate function\n    \n    return ((*pin_cfg >> shift_amt) & mask);\n}\n\n// Assumes `pin` is already in output mode.\n// Does nothing if `pin` is not valid, or if value is not 0 or 1.\nvoid gpio_write(gpio_id_t pin, int value) {\n    // Check pin is valid\n    if (!(gpio_id_is_valid(pin))) {\n        return;\n    }\n\n    if (!(value == 0 || value == 1)) {\n        return;\n    }\n    \n    // Get pin group and index\n    gpio_pin_t gp = get_group_and_index(pin);\n\n    // Pointer to pin's data register\n    volatile unsigned int *pin_data = get_data_reg(gp.group);\n\n    // Write value to correct position for pin's data\n    unsigned int shift_amt = gp.pin_index;\n    unsigned int mask = 1 << shift_amt; // 1 bit for pin data\n    \n    *pin_data &= (~mask); // mask out only current value to be 0\n    *pin_data |= value << shift_amt; // write value at pin's data position\n}\n\nint gpio_read(gpio_id_t pin) {\n    // Check pin valid\n    if (!(gpio_id_is_valid(pin))) {\n        return GPIO_INVALID_REQUEST;\n    }\n\n    // Get pin group and index\n    gpio_pin_t gp = get_group_and_index(pin);\n\n    // Pointer to pin's data register\n    volatile unsigned int *pin_data = get_data_reg(gp.group);\n\n    // Mask out value of pin data\n    unsigned int shift_amt = gp.pin_index;\n    unsigned int mask = 1;\n\n    // Shift pin data bit to least significant bit, then mask it out\n    return ((*pin_data >> shift_amt) & mask);\n}\n\n",
          "comments": []
        },
        "start.s": {
          "lines": "/* File: start.s\n * -------------\n * These asm instuctions go first in binary image, they will be\n * the first to be executed in a newly loaded program.\n */\n .attribute arch, \"rv64imac_zicsr\"\n\n# Identify this section as the one to go first in binary image\n.section \".text.start\"\n\n.globl _start\n_start:\n    csrc    mstatus, 1<<3   # global disable interrupts, mstatus.mie = 0\n    la      t0,_trap_handler\n    csrw    mtvec,t0        # install trap handler\n    lui     sp,0x60000      # init stack at 0x60000000 (grows down)\n    jal     _cstart\n\nhang: j hang\n\n.align 8\n_trap_handler:\n    j _trap_handler        # if exception raised, hang\n",
          "comments": []
        },
        "clock.c": {
          "lines": "/* File: clock.c\n * -------------\n * Create a breadboard clock using GPIO and timer functions.\n *\n * Lisa Fung\n */\n#include \"gpio.h\"\n#include \"timer.h\"\n\n// Segment and digit arrays, button to hold corresponding pins\nunsigned int segment[7] = {GPIO_PD17, GPIO_PB6, GPIO_PB12, GPIO_PB11, GPIO_PB10, GPIO_PE17, GPIO_PB0}; // {A,B,C,D,E,F,G}\nunsigned int digit[4] = {GPIO_PB4, GPIO_PB3, GPIO_PB2, GPIO_PC0}; // {D1,D2,D3,D4}\nunsigned int button = GPIO_PG13;\nunsigned int button2 = GPIO_PG12; // second button for extension\n\n// Array to hold each hex digit 0-9,A-F using 8-bit patterns\n// Each 8-bit pattern has form 0b0GFEDCBA, where A-G are clock display segments\nunsigned char pattern_hex[16] =\n    {0b00111111,\n    0b00000110,\n    0b01011011,\n    0b01001111,\n    0b01100110,\n    0b01101101,\n    0b01111101,\n    0b00000111,\n    0b01111111,\n    0b01100111,\n    0b01110111,\n    0b01111100,\n    0b00111001,\n    0b01011110,\n    0b01111001,\n    0b01110001};\n\n/*\n * `config_clock`\n *\n * Configures segment and digit pins as output, and button pin as input.\n */\nvoid config_clock() {\n    for (int i = 0; i < 7; i++) {  // configure segments\n        gpio_set_output(segment[i]);\n    }\n    for (int i = 0; i < 4; i++) {  // configure digits\n        gpio_set_output(digit[i]);\n    }\n    gpio_set_input(button); // configure button\n    gpio_set_input(button2); // configure button2 for extension\n}\n\n\n/*\n * `display_pattern`\n *\n * Displays pattern at index `pat_index` of `pattern_list` by turning\n * appropriate segments on.\n *\n * @param  pat_index  index of pattern in `pattern_list` to display\n *         pattern_list  list of all 8-bit patterns\n * \n * Assumes `pat_index` is a valid index of pattern_list.\n */\nvoid display_pattern(unsigned int pat_index, const unsigned char pattern_list[]) {\n    for (unsigned int i = 0; i < 7; i++) { // iterate over segments A-G\n        int value = (pattern_list[pat_index] >> i) & 1; // mask out value\n        gpio_write(segment[i], value);\n    }\n}\n\n/*\n * `display_blank`\n *\n * Displays a blank pattern with all segments turned off.\n */\nvoid display_blank() {\n    for (unsigned int i = 0; i < 7; i++) { // iterate over segments A-G\n        gpio_write(segment[i], 0);\n    }  \n}\n\n/*\n * `check_digits`\n *\n * Iterates through each digit and each pattern to check the display.\n *\n * @param  pattern_list  list of all 8-bit patterns\n *         num_patterns  number of patterns in `pattern_list`\n */\nvoid check_digits(const unsigned char pattern_list[], unsigned int num_patterns) {\n    // Adapted from starter code in `test_gpio_timer.c`\n    while (1) { // loop forever (finish via button press, see below)\n        for (int i = 0; i < 4; i++) {   // iterate over digits\n            gpio_write(digit[i], 1);    // turn on digit\n            for (int j = 0; j < num_patterns; j++) {   // iterate over patterns\n                display_pattern(j, pattern_list);  // display pattern\n                timer_delay_ms(500);\n                display_blank();  // turn off\n                if (gpio_read(button) == 0) return;  // stop when button pressed\n            }\n            gpio_write(digit[i], 0);    // turn off digit\n        }\n    }\n}\n\n\n/*\n * `display_refresh_loop`\n *\n * Iterate through digits and corresponding patterns one-by-one in quick \n * succession to create effect of displaying different digits simultaneously.\n *\n * @param  pat_indices   array of size 4 with indices of patterns in \n *                       `pattern_list` to display at once\n *         pattern_list  list of all 8-bit patterns\n *         duration  number of microseconds (us) to display pattern\n *         adjust    ticks to decrease from duration (experimentally determined),\n *                   accounts for time taken for other code to execute\n * \n * Assumes `pat_indices` contains valid indices of `pattern_list`.\n */\nvoid display_refresh_loop(unsigned int pat_indices[], const unsigned char\n                          pattern_list[], unsigned int duration, unsigned int adjust) {\n    unsigned long start = timer_get_ticks();\n    while (timer_get_ticks() - start < TICKS_PER_USEC * duration - adjust) {\n        for (int i = 0; i < 4; i++) { // Iterate over digits quickly\n            gpio_write(digit[i], 1); // Turn on digit\n            display_pattern(pat_indices[i], pattern_list); // Turn on pattern\n            timer_delay_us(2500); // Wait\n            display_blank(); // Turn off pattern\n            gpio_write(digit[i], 0); // Turn off digit\n        }\n    }\n}\n\n/*\n * `update_time_pattern`\n *\n * Updates the pattern indices in array `time_pattern` to hold digit pattern indices \n * in `time`.\n *\n * @param  time          current time to display in format MMSS\n *         time_pattern  array of size 4 with digit pattern indices from `time`\n */\nvoid update_time_pattern(unsigned int time, unsigned int *time_pattern) {\n    for (int i = 3; i >= 0; i--) {\n        time_pattern[i] = time % 10;\n        time /= 10;\n    }\n}\n\n/*\n * `display_done`\n *\n * Displays final message with alternating box animation when countdown reaches 0000.\n */\nvoid display_done() {\n    // Turn on all digits\n    for (int i = 0; i < 4; i++) {\n        gpio_write(digit[i], 1);\n    }\n\n    // Final message with alternating boxes\n    unsigned char pattern_box[2] = {0b001100011, 0b01011100};\n    unsigned int box_indices1[4] = {0, 1, 0, 1};    \n    unsigned int box_indices2[4] = {1, 0, 1, 0};\n\n    unsigned int half_sec = 500000; // microseconds in half-second\n    \n    while (gpio_read(button) == 1) {        \n        // Display box_indices1 for half sec\n        display_refresh_loop(box_indices1, pattern_box, half_sec, 0);\n\n        // Display box_indices2 for half sec\n        display_refresh_loop(box_indices2, pattern_box, half_sec, 0);\n    }\n\n    // Turn off all digits\n    for (int i = 0; i < 4; i++) {\n        gpio_write(digit[i], 0);\n    }\n}\n\n/*\n * `countdown`\n *\n * Displays a countdown beginning with `start_time` until 0000.\n *\n * @param  start_time  initial time to display in format MMSS\n *         pattern_list  list of all 8-bit patterns\n */\nvoid countdown(unsigned int start_time, const unsigned char pattern_list[]) {\n    unsigned int time = start_time;\n    \n    // Convert time to pattern\n    unsigned int time_pattern[4];\n    update_time_pattern(time, time_pattern);\n\n    unsigned int adjust = 80000; // time taken for non-display code to execute\n    unsigned int one_sec = 1000000; // number of microseconds (us) in 1 second\n\n    // Display initial time while button not pressed\n    while (gpio_read(button) == 1) {        \n        display_refresh_loop(time_pattern, pattern_list, 100, 0);\n    }\n    \n    // Loop for countdown once button pressed\n    while (time > 0) {\n        // Display time_pattern for 1 second\n        display_refresh_loop(time_pattern, pattern_list, one_sec, adjust);\n        \n        // Update time to decrease\n        if (time % 100 == 0) { // Convert MM:00 to M(M-1):59\n            time -= 100;\n            time += 59;\n        }\n        else { // Convert MM:SS to MM:S(S-1)\n            time -= 1;\n        }\n\n        // Update time pattern\n        update_time_pattern(time, time_pattern);        \n    }\n\n    // Display final message when time is 0000\n    display_done();\n}\n\n\nvoid main(void) {\n    timer_init();\n    gpio_init();\n    \n    config_clock(); // Configure clock output pins\n\n    // Check all digits display properly\n    // check_digits(pattern_hex, 0x10);\n\n    // Countdown\n    int start_time = 314;\n    countdown(start_time, pattern_hex);   \n}\n",
          "comments": []
        },
        "larson.c": {
          "lines": "/* File: larson.c\n * --------------\n * Sample program that demonstrates use of gpio and timer library modules.\n * (Larson scanner rewritten in C)\n * Author: Julie Zelenski <zelenski@cs.stanford.edu>\n */\n#include \"gpio.h\"\n#include \"timer.h\"\n\n#define NUM_LEDS 4\n#define DELAY_MS  (1000/NUM_LEDS)  // frequency 1 sweep per sec\n\nvoid blink(gpio_id_t pin) {\n    gpio_write(pin, 1);\n    timer_delay_ms(DELAY_MS);\n    gpio_write(pin, 0);\n    timer_delay_ms(DELAY_MS);\n}\n\nvoid main(void) {\n    gpio_id_t leds[NUM_LEDS] = { GPIO_PB0, GPIO_PB1, GPIO_PB2, GPIO_PB3 };\n    gpio_init();\n    for (int i = 0; i < NUM_LEDS; i++) {\n        gpio_set_output(leds[i]);\n    }\n\n    int cur = 0;\n    while (1) {\n        for (int i = 0; i < NUM_LEDS-1; i++) {\n            blink(leds[cur++]); // move up\n        }\n        for (int i = 0; i < NUM_LEDS-1; i++) {\n            blink(leds[cur--]); // move down\n        }\n    }\n}\n",
          "comments": []
        },
        "test_gpio_timer.c": {
          "lines": "/* File: test_gpio_timer.c\n * -----------------------\n * Tests for GPIO functions and timer delay functions.\n */\n#include \"gpio.h\"\n#include \"timer.h\"\n\n// You call assert on an expression that you expect to be true. If expr\n// instead evaluates to false, then assert calls abort, which stops\n// your program and flashes onboard led.\n#define assert(expr) if(!(expr)) abort()\n\n// infinite loop that flashes onboard blue LED (GPIO PD18)\nvoid abort(void) {\n    volatile unsigned int *GPIO_CFG2 = (unsigned int *)0x02000098;\n    volatile unsigned int *GPIO_DATA = (unsigned int *)0x020000a0;\n\n    // Configure GPIO PD18 function to be output.\n    *GPIO_CFG2 = (*GPIO_CFG2 & ~(0xf00)) | 0x100;\n    while (1) { // infinite loop\n        *GPIO_DATA ^= (1 << 18); // invert value\n        for (volatile int delay = 0x100000; delay > 0; delay--) ; // wait\n    }\n}\n\n// Additional test function for using xfel write32 to test gpio_get_function\n// Commented out since these functions rely on xfel commands in mango-run\nvoid test_gpio_get_function_xfel(void) {\n    // Check default is disabled\n    // assert( gpio_get_function(GPIO_PC0) == GPIO_FN_DISABLED ); // Pass\n\n    // Set GPIO_PC0 to output (1) using xfel (PC1-PC7 disabled)\n    // xfel write32 0x02000060 0xfffffff1\n    // assert( gpio_get_function(GPIO_PC0) == GPIO_FN_OUTPUT ); // Pass\n    // assert( gpio_get_function(GPIO_PC1) == GPIO_FN_DISABLED ); // Pass\n    // assert( gpio_get_function(GPIO_PC4) == GPIO_FN_DISABLED ); // Pass\n    // assert( gpio_get_function(GPIO_PC7) == GPIO_FN_DISABLED ); // Pass\n\n    // Set GPIO_PC0 to input, GPIO_PC4 to ALT3, GPIO_PC7 to output\n    // xfel write32 0x02000060 0x1ff3fff0\n    // assert( gpio_get_function(GPIO_PC0) == GPIO_FN_INPUT ); // Pass\n    // assert( gpio_get_function(GPIO_PC1) == GPIO_FN_DISABLED ); // Pass\n    // assert( gpio_get_function(GPIO_PC4) == GPIO_FN_ALT3 ); // Pass\n    // assert( gpio_get_function(GPIO_PC7) == GPIO_FN_OUTPUT ); // Pass\n    // assert( gpio_get_function(GPIO_PC6) == GPIO_FN_DISABLED ); // Pass\n\n    // Set GPIO_PD7 to GPIO_FN_INTERRUPT, GPIO_PD6 to input, and\n    // check neighboring pins disabled\n    // xfel write32 0x02000090 0xe0ffffff\n    // assert( gpio_get_function(GPIO_PD7) == GPIO_FN_INTERRUPT ); // Pass\n    // assert( gpio_get_function(GPIO_PD6) == GPIO_FN_INPUT ); // Pass\n    // assert( gpio_get_function(GPIO_PD8) == GPIO_FN_DISABLED ); // Pass\n    // assert( gpio_get_function(GPIO_PD0) == GPIO_FN_DISABLED ); // Pass\n    // assert( gpio_get_function(GPIO_PD5) == GPIO_FN_DISABLED ); // Pass\n\n    // Check PG_CFG1, PG_CFG2 register\n    // Set GPIO_PG15 to INPUT, GPIO_PG13 to ALT5, GPIO_PG8 to OUTPUT\n    // xfel write32 0x02000124 0x0f5ffff1\n    // assert( gpio_get_function(GPIO_PG16) == GPIO_FN_DISABLED ); // Pass\n    // assert( gpio_get_function(GPIO_PG15) == GPIO_FN_INPUT ); // Pass\n    // assert( gpio_get_function(GPIO_PG14) == GPIO_FN_DISABLED ); // Pass\n    // assert( gpio_get_function(GPIO_PG13) == GPIO_FN_ALT5 ); // Pass\n    // assert( gpio_get_function(GPIO_PG12) == GPIO_FN_DISABLED ); // Pass\n    // assert( gpio_get_function(GPIO_PG9) == GPIO_FN_DISABLED ); // Pass\n    // assert( gpio_get_function(GPIO_PG8) == GPIO_FN_OUTPUT ); // Pass\n    // assert( gpio_get_function(GPIO_PG7) == GPIO_FN_DISABLED ); // Pass\n    \n    // Check PE_CFG2 register\n    // Set GPIO_PE17 to ALT6, check GPIO_PE16 disabled\n    // xfel write32 0x020000C8 0x6f\n    // assert( gpio_get_function(GPIO_PE17) == GPIO_FN_ALT6 ); // Pass\n    // assert( gpio_get_function(GPIO_PE16) == GPIO_FN_DISABLED ); // Pass\n    // assert( gpio_get_function(GPIO_PE15) == GPIO_FN_DISABLED ); // Pass\n}\n\nvoid test_gpio_set_get_function(void) {\n    /* GPIO-SET-GET TEST CASE 0 (provided). All cases passed */\n    // Check GPIO_PC0 pin default, get, set work\n    \n    // Test get pin function (pin defaults to disabled)\n    assert( gpio_get_function(GPIO_PC0) == GPIO_FN_DISABLED ); // Pass\n\n    // Set pin to output, confirm get returns what was set\n    gpio_set_output(GPIO_PC0);\n    assert( gpio_get_function(GPIO_PC0) == GPIO_FN_OUTPUT ); // Pass\n\n    // Set pin to input, confirm get returns what was set\n    gpio_set_input(GPIO_PC0);\n    assert( gpio_get_function(GPIO_PC0) == GPIO_FN_INPUT ); // Pass\n\n    \n    /* GPIO-SET-GET TEST CASE 1. All cases passed. Note PF_CFG exception */\n    // Check get function matches what is set for all pins\n    // except skip pins GPIO_PB8, GPIO_PB9, GPIO_PD18 (special function)\n    \n    // Disable GPIO_PC0 to default\n    gpio_set_function(GPIO_PC0, GPIO_FN_DISABLED);\n    assert( gpio_get_function(GPIO_PC0) == GPIO_FN_DISABLED ); // Pass\n\n    // Condensed function to go through all pins\n    for (gpio_id_t pin = GPIO_ID_FIRST; pin <= GPIO_ID_LAST; pin++) {\n        /* GPIO-SET-GET TEST CASE 1 */\n        \n        // Check pin is valid and is not special pin\n        if ( (pin >= GPIO_PB0 && pin < GPIO_PB8)\n             || (pin > GPIO_PB9 && pin <= GPIO_PB0 + GPIO_PB_LAST_INDEX)\n             || (pin >= GPIO_PC0 && pin <= GPIO_PC0 + GPIO_PC_LAST_INDEX)\n             || (pin >= GPIO_PD0 && pin < GPIO_PD18)\n             || (pin > GPIO_PD18 && pin <= GPIO_PD0 + GPIO_PD_LAST_INDEX)\n             || (pin >= GPIO_PE0 && pin <= GPIO_PE0 + GPIO_PE_LAST_INDEX)\n             //|| (pin >= GPIO_PF0 && pin <= GPIO_PF0 + GPIO_PF_LAST_INDEX)\n             || (pin >= GPIO_PG0 && pin <= GPIO_PG0 + GPIO_PG_LAST_INDEX)\n             ) {\n            \n            // Check pin's default function is disabled\n            assert( gpio_get_function(pin) == GPIO_FN_DISABLED );\n            \n            // Set pin to output, confirm get returns what was set\n            gpio_set_output(pin);\n            assert( gpio_get_function(pin) == GPIO_FN_OUTPUT );\n            \n            // Set pin to input, confirm get returns what was set\n            gpio_set_input(pin);\n            assert( gpio_get_function(pin) == GPIO_FN_INPUT );\n\n            /* GPIO-SET-GET TEST CASE 3. All cases passed. */\n            // Check invalid function for valid pin does nothing\n            \n            gpio_set_function(pin, 9); // reserved function\n            assert( gpio_get_function(pin) == GPIO_FN_INPUT ); // same as above\n            \n            gpio_set_function(pin, 13); // reserved function\n            assert( gpio_get_function(pin) == GPIO_FN_INPUT ); // same as above\n            \n            gpio_set_function(pin, 16); // out of function range\n            assert( gpio_get_function(pin) == GPIO_FN_INPUT ); // same as above\n\n            gpio_set_function(pin, GPIO_FN_DISABLED);            \n            assert( gpio_get_function(pin) == GPIO_FN_DISABLED );\n        }\n        \n        // Separated PF_CFG0 checks due to odd default values (0x0f4f4f44)\n        // Explanation from Julie: FEL configures gpios PF 0,1,3,5 to\n        // alt function 4 to enable JTAG communication.\n        // All passed.\n        else if (pin >= GPIO_PF0 && pin <= GPIO_PF0 + GPIO_PF_LAST_INDEX) {\n            if ((pin == GPIO_PF2) || (pin == GPIO_PF4) || (pin == GPIO_PF6)) {\n                // Set pin to output, confirm get returns what was set\n                gpio_set_output(pin);\n                assert( gpio_get_function(pin) == GPIO_FN_OUTPUT );\n            \n                // Set pin to input, confirm get returns what was set\n                gpio_set_input(pin);\n                assert( gpio_get_function(pin) == GPIO_FN_INPUT );\n            \n                gpio_set_function(pin, GPIO_FN_DISABLED);            \n                assert( gpio_get_function(pin) == GPIO_FN_DISABLED );\n            }\n            else {\n                // Check FEL configured gpios PF 0,1,3,5 have ALT4 function\n                // All passed.\n                assert( gpio_get_function(pin) == GPIO_FN_ALT4 );\n            }\n        }\n                 \n        /* GPIO-SET-GET TEST CASE 3. All cases passed. */\n        // Check invalid pins\n        else if ((pin != GPIO_PB8) && (pin != GPIO_PB9) && (pin != GPIO_PD18)) {\n            // Set invalid pin to output, should have no action\n            // confirm get returns GPIO_INVALID_REQUEST\n            gpio_set_output(pin);\n            assert( gpio_get_function(pin) == GPIO_INVALID_REQUEST );\n            \n            // Set invalid pin to input, should have no action\n            // confirm get returns GPIO_INVALID_REQUEST\n            gpio_set_input(pin);\n            assert( gpio_get_function(pin) == GPIO_INVALID_REQUEST );\n\n            gpio_set_function(pin, GPIO_FN_ALT6);\n            assert( gpio_get_function(pin) == GPIO_INVALID_REQUEST );\n        }\n    }\n\n    /* GPIO-SET-GET TEST CASE 2. All cases passed. */\n    // Can configure pin to input, output, or alternate functions\n    // Pin can be reconfigured\n\n    gpio_set_function(GPIO_PD12, GPIO_FN_ALT5);            \n    assert( gpio_get_function(GPIO_PD12) == GPIO_FN_ALT5 );\n    \n    gpio_set_function(GPIO_PD13, GPIO_FN_INPUT);            \n    assert( gpio_get_function(GPIO_PD13) == GPIO_FN_INPUT );\n\n    gpio_set_function(GPIO_PD12, GPIO_FN_INPUT);            \n    assert( gpio_get_function(GPIO_PD12) == GPIO_FN_INPUT );\n\n    gpio_set_function(GPIO_PD13, GPIO_FN_ALT2);            \n    assert( gpio_get_function(GPIO_PD13) == GPIO_FN_ALT2 );\n\n    gpio_set_function(GPIO_PD12, GPIO_FN_OUTPUT);            \n    assert( gpio_get_function(GPIO_PD12) == GPIO_FN_OUTPUT );\n\n    \n    /* GPIO-SET-GET TEST CASE 4. All cases passed. */\n    // Each pin's configuration is independent of others\n    // Builds from TEST CASE 2 above\n\n    // Check other PD pins unaffected\n    assert( gpio_get_function(GPIO_PD14) == GPIO_FN_DISABLED );\n    assert( gpio_get_function(GPIO_PD15) == GPIO_FN_DISABLED );\n    assert( gpio_get_function(GPIO_PD16) == GPIO_FN_DISABLED );\n    assert( gpio_get_function(GPIO_PD11) == GPIO_FN_DISABLED );\n    assert( gpio_get_function(GPIO_PD8) == GPIO_FN_DISABLED );    \n    assert( gpio_get_function(GPIO_PD7) == GPIO_FN_DISABLED );\n    \n}\n\n// Additional test function for using xfel write32 to test gpio_read\n// NOTE: Must turn off other tests when testing xfel since defaults will change\n// Commented out since these functions rely on xfel commands in mango-run\nvoid test_gpio_read_xfel(void) {\n    // Check default data at GPIO_PG0 is 0\n    // assert ( gpio_read(GPIO_PG0) == 0 ); // Pass\n        \n    // Set GPIO_PC1 to output (1) and data to high (1) using xfel (other PC disabled)\n    // xfel write32 0x02000060 0xffffff1f\n    // xfel write32 0x02000070 0x2\n    // NOTE: xfel does not accept binary arguments (e.g. 0b10). Use hex instead\n    // Setup: connected 1K resistor, LED to PC1. LED lit up!\n    // All cases passed.\n    /* assert( gpio_get_function(GPIO_PC1) == GPIO_FN_OUTPUT ); */\n    /* assert( gpio_read(GPIO_PC0) == 0 ); */\n    /* assert( gpio_read(GPIO_PC1) == 1 ); */\n    /* assert( gpio_read(GPIO_PC2) == 0 ); */\n    /* assert( gpio_read(GPIO_PC3) == 0 ); */\n}\n\n\nvoid test_gpio_read_write(void) {\n    /* GPIO-READ-WRITE TEST CASE 0 (provided). All cases passed. */\n    // set pin to output before gpio_write\n    gpio_set_output(GPIO_PB4);\n\n    // gpio_write low, confirm gpio_read reads what was written\n    gpio_write(GPIO_PB4, 0);\n    assert( gpio_read(GPIO_PB4) ==  0 );\n\n    // gpio_write high, confirm gpio_read reads what was written\n    gpio_write(GPIO_PB4, 1);\n    assert( gpio_read(GPIO_PB4) ==  1 );\n\n    // gpio_write low, confirm gpio_read reads what was written\n    gpio_write(GPIO_PB4, 0);\n    assert( gpio_read(GPIO_PB4) ==  0 );\n\n    gpio_set_function(GPIO_PB4, GPIO_FN_DISABLED);\n\n    \n    /* GPIO-READ-WRITE TEST CASE 1. All cases passed. */\n    // Check read value matches what was written for all valid/non-special pins\n    // Skip pins PB8, PB9, PD18\n\n    // Condensed function to go through all pins\n    for (gpio_id_t pin = GPIO_ID_FIRST; pin <= GPIO_ID_LAST; pin++) {\n        /* GPIO-READ-WRITE TEST CASE 1 */\n        \n        // Check pin is valid and is not special pin\n        if ( (pin >= GPIO_PB0 && pin < GPIO_PB8)\n             || (pin > GPIO_PB9 && pin <= GPIO_PB0 + GPIO_PB_LAST_INDEX)\n             || (pin >= GPIO_PC0 && pin <= GPIO_PC0 + GPIO_PC_LAST_INDEX)\n             || (pin >= GPIO_PD0 && pin < GPIO_PD18)\n             || (pin > GPIO_PD18 && pin <= GPIO_PD0 + GPIO_PD_LAST_INDEX)\n             || (pin >= GPIO_PE0 && pin <= GPIO_PE0 + GPIO_PE_LAST_INDEX)\n             //|| (pin >= GPIO_PF0 && pin <= GPIO_PF0 + GPIO_PF_LAST_INDEX)\n             || (pin >= GPIO_PG0 && pin <= GPIO_PG0 + GPIO_PG_LAST_INDEX)\n             ) {\n\n            // set pin to output before gpio_write\n            gpio_set_output(pin);\n\n            // gpio_write low, confirm gpio_read reads what was written\n            gpio_write(pin, 0);\n            assert( gpio_read(pin) ==  0 );\n\n            // gpio_write high, confirm gpio_read reads what was written\n            gpio_write(pin, 1);\n            assert( gpio_read(pin) ==  1 );\n\n            // gpio_write low, confirm gpio_read reads what was written\n            gpio_write(pin, 0);\n            assert( gpio_read(pin) ==  0 );\n\n            gpio_set_function(pin, GPIO_FN_DISABLED);\n        }\n        \n        // Check PF pins. All cases passed.\n        else if (pin >= GPIO_PF0 && pin <= GPIO_PF0 + GPIO_PF_LAST_INDEX) {\n            if ((pin == GPIO_PF2) || (pin == GPIO_PF4) || (pin == GPIO_PF6)) {\n                // set pin to output before gpio_write\n                gpio_set_output(pin);\n\n                // gpio_write low, confirm gpio_read reads what was written\n                gpio_write(pin, 0);\n                assert( gpio_read(pin) ==  0 );\n\n                // gpio_write high, confirm gpio_read reads what was written\n                gpio_write(pin, 1);\n                assert( gpio_read(pin) ==  1 );\n\n                /* GPIO-READ-WRITE TEST CASE 3. All cases passed. */\n                // Check invalid values (for valid pins) have no effect.\n                gpio_write(pin, 2); // Invalid value, should have no effect\n                assert( gpio_read(pin) == 1 ); // from writing 1 above\n                \n                // gpio_write low, confirm gpio_read reads what was written\n                gpio_write(pin, 0);\n                assert( gpio_read(pin) ==  0 );\n\n                gpio_set_function(pin, GPIO_FN_DISABLED);\n            }\n        }\n\n        /* GPIO-READ-WRITE TEST CASE 3. All cases passed. */\n        // Check invalid pins, valid and invalid values\n        else if ((pin != GPIO_PB8) && (pin != GPIO_PB9) && (pin != GPIO_PD18)) {\n            gpio_set_output(pin); // Should have no effect\n\n            gpio_write(pin, 1); // Valid value, should have no effect\n            assert( gpio_read(pin) == GPIO_INVALID_REQUEST );\n\n            gpio_write(pin, 0); // Valid value, should have no effect\n            assert( gpio_read(pin) == GPIO_INVALID_REQUEST );\n\n            gpio_write(pin, 2); // Invalid value, should have no effect\n            assert( gpio_read(pin) == GPIO_INVALID_REQUEST );\n\n            gpio_set_function(pin, GPIO_FN_DISABLED); // Should have no effect\n        }\n    }\n    \n\n    /* GPIO-READ-WRITE TEST CASE 2. All cases passed. */\n    // Check each pin's state is independent of others\n    \n    // Set GPIO_PD14 to output and on, check that other PDs are off\n    // LED connected to PD14. Turns on! All cases passed.\n    gpio_set_output(GPIO_PD14);\n    gpio_write(GPIO_PD14, 1);\n    assert( gpio_read(GPIO_PD14) == 1 );\n    \n    assert( gpio_get_function(GPIO_PD15) == GPIO_FN_DISABLED );\n    assert( gpio_read(GPIO_PD15) == 0 );\n    assert( gpio_get_function(GPIO_PD13) == GPIO_FN_DISABLED );\n    assert( gpio_read(GPIO_PD13) == 0 );\n\n    assert( gpio_read(GPIO_PD8) == 0 );\n    assert( gpio_read(GPIO_PD7) == 0 );\n    assert( gpio_read(GPIO_PD16) == 0 );\n    assert( gpio_read(GPIO_PD12) == 0 );\n\n    \n    /* GPIO-READ-WRITE TEST CASE 4. All passed. Note PG13, PG12 odd behavior  */\n    // Physical check that LED turns on when PD17, PB6, PB4, PG13 are output and on\n\n    // LED connected to PD17. Turns on! Passed.\n    gpio_set_output(GPIO_PD17);\n    gpio_write(GPIO_PD17, 1);\n    assert( gpio_read(GPIO_PD17) ==  1 );\n    // Check disabling pin does not affect data\n    gpio_set_function(GPIO_PD17, GPIO_FN_DISABLED);\n    assert( gpio_read(GPIO_PD17) ==  1 );\n\n    // Reenable pin to turn off data\n    gpio_set_output(GPIO_PD17);\n    gpio_write(GPIO_PD17, 0);\n    assert( gpio_read(GPIO_PD17) ==  0 );    \n    gpio_set_function(GPIO_PD17, GPIO_FN_DISABLED);\n\n    \n    // LED connected to PB6. Turns on! Passed.\n    gpio_set_output(GPIO_PB6);\n    gpio_write(GPIO_PB6, 1);\n    assert( gpio_read(GPIO_PB6) ==  1 );    \n    gpio_write(GPIO_PB6, 0);\n    assert( gpio_read(GPIO_PB6) ==  0 );    \n    gpio_set_function(GPIO_PB6, GPIO_FN_DISABLED);\n\n    // LED connected to PB4. Turns on! Passed.\n    gpio_set_output(GPIO_PB4);\n    gpio_write(GPIO_PB4, 1);\n    assert( gpio_read(GPIO_PB4) ==  1 );    \n    gpio_write(GPIO_PB4, 0);\n    assert( gpio_read(GPIO_PB4) ==  0 );\n    gpio_set_function(GPIO_PB4, GPIO_FN_DISABLED);\n\n    // LED connected to PG13.\n    // Odd behavior: When I power on the MangoPi, the LED is on (slightly dimmer).\n    // And when I disable the GPIO_PG13 pin, the LED turns back on. (same for PG12)\n    // So changed code to turn it off. LED turned off. Passed.\n    gpio_set_output(GPIO_PG13);\n    gpio_write(GPIO_PG13, 0);\n    assert( gpio_read(GPIO_PG13) ==  0 );    \n    gpio_set_function(GPIO_PG13, GPIO_FN_DISABLED);\n}\n\n// Tests reading input from a button.\n// Placed in separate function and commented out\n// so other tests with PG13 as output will not affect button.\nvoid test_gpio_read_button(void) {    \n    /* GPIO-READ-WRITE TEST CASE 5. All cases passed. */\n    // Physical check that (pullup) button press sets data to 0 at PG13, PG12\n\n    // Case 1: Button not pressed\n    /* gpio_write(GPIO_PG13, 1); */\n    /* assert( gpio_read(GPIO_PG13) ==  1 ); */\n    /* gpio_set_input(GPIO_PG13);     */\n    /* assert( gpio_read(GPIO_PG13) ==  1 ); // Button NOT pressed */\n\n    // Case 2: Button pressed\n    /* gpio_set_input(GPIO_PG13);     */\n    /* assert( gpio_read(GPIO_PG13) ==  0 ); // Button pressed */\n    // Result: Hold button pressed before running `make test`, no blinking ACT_LED\n    // When button not pressed, ACT_LED blinks\n}\n\nvoid test_timer(void) {\n    // Check timer tick count begins at zero/positive number. Passed.\n    assert ( timer_get_ticks() >= 0 );\n    \n    // Test timer tick count incrementing\n    unsigned long start = timer_get_ticks();\n    for( int i=0; i<10; i++ ) { /* Spin */ }\n    unsigned long finish = timer_get_ticks();\n    assert( finish > start );\n\n    // Test timer delay\n    int usecs = 100;\n    start = timer_get_ticks();\n    timer_delay_us(usecs);\n    finish = timer_get_ticks();\n    assert( finish >= start + usecs*TICKS_PER_USEC );\n\n    // Test timer delay for 1.5 seconds (ACT_LED is on for few_sec). Passed.\n    int few_sec = 1.5;\n    start = timer_get_ticks();\n    timer_delay(few_sec);\n    finish = timer_get_ticks();\n    assert( finish - start >= few_sec * 1000000 * TICKS_PER_USEC );    \n    assert( finish - start <= (few_sec * 1000100) * TICKS_PER_USEC );\n\n    // Test timer delay for 40 milliseconds. Passed.\n    int few_ms = 40;\n    start = timer_get_ticks();\n    timer_delay_ms(few_ms);\n    finish = timer_get_ticks();\n    assert( finish >= start + few_ms * 1000 * TICKS_PER_USEC );\n\n    // Check time between getting ticks. Passed (might have been optimized away).\n    start = timer_get_ticks();\n    finish = timer_get_ticks();\n    assert( finish - start >= 0 );\n}\n\nvoid test_breadboard(void) {\n    unsigned int segment[7] = {GPIO_PD17, GPIO_PB6, GPIO_PB12, GPIO_PB11, GPIO_PB10, GPIO_PE17, GPIO_PB0};\n    unsigned int digit[4] = {GPIO_PB4, GPIO_PB3, GPIO_PB2, GPIO_PC0};\n\n    unsigned int button = GPIO_PG13;\n\n    for (int i = 0; i < 7; i++) {  // configure segments\n        gpio_set_output(segment[i]);\n    }\n    for (int i = 0; i < 4; i++) {  // configure digits\n        gpio_set_output(digit[i]);\n    }\n    gpio_set_input(button); // configure button\n\n    while (1) { // loop forever (finish via button press, see below)\n        for (int i = 0; i < 4; i++) {   // iterate over digits\n            gpio_write(digit[i], 1);    // turn on digit\n            for (int j = 0; j < 7; j++) {   // iterate over segments\n                gpio_write(segment[j], 1);  // turn on segment\n                timer_delay_ms(200);\n                gpio_write(segment[j], 0);  // turn off segment\n                if (gpio_read(button) == 0) return;  // stop when button pressed\n            }\n            gpio_write(digit[i], 0);    // turn off digit\n        }\n    }\n}\n\nvoid main(void) {\n    gpio_init();\n    timer_init();\n\n    // Uncomment the call to each test function below when you have implemented\n    // the functions and are ready to test them\n\n    // test_gpio_get_function_xfel();\n    test_gpio_set_get_function();\n    \n    // test_gpio_read_xfel();\n    test_gpio_read_write();\n    // test_gpio_read_button();\n    \n    test_timer();\n    test_breadboard();\n}\n",
          "comments": []
        }
      }
    },
    "assign1": {
      "name": "assign1",
      "timeliness": {
        "submit": null,
        "retests": null,
        "extension": null
      },
      "test_totals": {
        "Larson application": {
          "total": 5,
          "passed": 0
        }
      },
      "test_results": {},
      "review": {}
    }
  }
}